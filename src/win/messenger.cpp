#include "messenger.h"
#include "widget.h"
#include "types.h"

// forwardLeftMouseUp does the same exact thing forwardRightMouseDown
// and forwardRightMouseUp would do, so we call it instead of defining
// two new functions. Perhaps it would be wiser to rename it to
// something along the lines of forwardMouseMessageNoFocus or something idk
#define forwardRightMouseDown forwardLeftMouseUp
#define forwardRightMouseUp forwardLeftMouseUp

// Found in Widget.cpp
extern Widget* g_pCursorWidget;

/// <summary>
/// Forwards a message sent to a Widget to either itself or a child Widget,
/// depending on who it is targeted for. For example, if the top level Widget
/// is clicked, then this function calculates which Widget is below the cursor
/// and then sends a forwards the message to it with the appropriate parameters.
/// </summary>
/// <param name="pWidget">Pointer to the Widget that the message was sent to</param>
/// <param name="message">Message struct generated by MessageGenerator containg information about the message</param>
bool Messenger::forwardMessage(Widget* pWidget, const Message& message)
{
	switch (message.code)
	{
	case Message::Code::LEFT_MOUSE_DOWN:
		return forwardLeftMouseDown(pWidget, message);

	case Message::Code::LEFT_MOUSE_UP:
		return forwardLeftMouseUp(pWidget, message);

	case Message::Code::RIGHT_MOUSE_DOWN:
		return forwardRightMouseDown(pWidget, message);

	case Message::Code::RIGHT_MOUSE_UP:
		return forwardRightMouseUp(pWidget, message);

	case Message::Code::WINDOW_RESIZED:
		return forwardResize(pWidget, message);

	case Message::Code::KEY_PRESSED:
		return forwardKeyPressed(pWidget, message);

	case Message::Code::KEY_RELEASED:
		return forwardKeyReleased(pWidget, message);

	case Message::Code::GOT_FOCUS:
		return forwardGotFocus(pWidget, message);

	case Message::Code::TIMER:
		return forwardTimer(pWidget, message);

	case Message::Code::LOST_FOCUS:
		return false;

	case Message::Code::MOVING_MOUSE:
		return forwardDraggingMouse(pWidget, message);

	case Message::Code::MOUSE_LEFT:
		return false;

	case Message::Code::MOUSE_ENTER:
		return false;

	case Message::Code::CUSTOM:
		return false;
	}

	return false;
}

/// <summary>
/// </summary>
/// <param name="pReceiver">Pointer to the Widget that the message was sent to</param>
/// <param name="message">Message struct containing information</param>
/// <returns>Zero on success, non-zero on failure</returns>
bool Messenger::forwardLeftMouseDown(Widget* pReceiver, const Message& message)
{
	Point* point = reinterpret_cast<Point*>(message.data);

	Widget* pTarget = findChildWidgetUnderPoint(pReceiver, *point);

	if (pTarget)
	{
		// If the Widget clicked didn't already have focus, we kill the focus
		// of the previously focused Widget (if there was one) and we give
		// the focus to pTarget
		if (!pTarget->hasFocus())
		{
			Widget* pPrevious = Widget::getFocusWidget();

			if (pPrevious)
			{
				pPrevious->killFocus();
			}
			
			pTarget->setFocus();
		}

		if (pTarget == pReceiver)
		{
			absoluteToRelative(*point, pTarget);
			return false;
		}

		pTarget->postMessage(message);
	}

	return true;
}

/// <summary>
/// </summary>
/// <param name="pReceiver">Pointer to the Widget that the message was sent to</param>
/// <param name="message">Message struct containing information</param>
/// <returns>Zero on success, non-zero on failure</returns>
bool Messenger::forwardLeftMouseUp(Widget* pReceiver, const Message& message)
{
	Point* point = reinterpret_cast<Point*>(message.data);

	Widget* pTarget = findChildWidgetUnderPoint(pReceiver, *point);

	if (pReceiver == pTarget)
	{
		absoluteToRelative(*point, pTarget);
		return false;
	}

	else if (pTarget)
	{
		pTarget->postMessage(message);
	}

	return true;
}

/// <summary>
/// Always returns false, since a resize message is always meant for the Widget receiving it
/// </summary>
/// <param name="pReceiver">Pointer to the receiving Widget.</param>
/// <param name="message">Pointer to a size struct containing the new dimensions.</param>
/// <returns></returns>
bool Messenger::forwardResize(Widget* pReceiver, const Message& message)
{
	return false;
}

/// <summary>
/// Forwards the message to the Widget with focus
/// </summary>
/// <param name="pReceiver">Pointer to the receiving Widget.</param>
/// <param name="message">Pointer to a KeyMessageInfo struct</param>
/// <returns></returns>
bool Messenger::forwardKeyPressed(Widget* pReceiver, const Message& message)
{
	Widget* pFocusWidget = Widget::getFocusWidget();

	if (pFocusWidget)
	{
		if (pFocusWidget == pReceiver)
		{
			return false;
		}

		pFocusWidget->postMessage(message);
		return true;
	}

	// If no Widget is focused, then we act as if we didn't forward the message
	// and we let the top level Widget process this
	return false;
}

/// <summary>
/// Forwards the message to the Widget with focus.
/// </summary>
/// <param name="pReceiver">Pointer to the receiving Widget.</param>
/// <param name="message">Pointer to a KeyMessageInfo struct</param>
/// <returns></returns>
bool Messenger::forwardKeyReleased(Widget* pReceiver, const Message& message)
{
	Widget* pFocusWidget = Widget::getFocusWidget();

	if (pFocusWidget)
	{
		if (pFocusWidget == pReceiver)
		{
			return false;
		}

		pFocusWidget->postMessage(message);
		return true;
	}

	// If no Widget is focused, then we act as if we didn't forward the message
	// and we let the top level Widget process this
	return false;
}

/// <summary>
/// Forwards the message to the Widget with focus.
/// </summary>
/// <param name="pReceiver">Pointer to the receiving Widget.</param>
/// <param name="message">NULL</param>
/// <returns></returns>
bool Messenger::forwardGotFocus(Widget* pReceiver, const Message& message)
{
	Widget* pWidget = Widget::getFocusWidget();

	if (pWidget)
	{
		if (pWidget == pReceiver)
		{ 
			return false;
		}

		pWidget->postMessage(message);
		return true;
	}

	// If no Widget is focused, then we act as if we didn't forward the message
	// and we let the top level Widget process this
	return false;
}

/// <summary>
/// Forwards the message to the Widget underneath the cursor.
/// Also updates the g_pCursorWidget variable.
/// </summary>
/// <param name="pReceiver"></param>
/// <param name="message"></param>
/// <returns></returns>
bool Messenger::forwardDraggingMouse(Widget* pReceiver, const Message& message)
{
	Point* point = reinterpret_cast<Point*>(message.data);
	Widget* pTarget = findChildWidgetUnderPoint(pReceiver, *point);

	if (pTarget)
	{
		if (pTarget == pReceiver)
		{
			// Say for example the cursor Widget, B, is the child of A
			// Then if we're hovering B, p
			if (g_pCursorWidget != pTarget)
			{
				Message message;
				message.code = Message::Code::MOUSE_ENTER;
				message.data = MessageGenerator::generateMouseMessageInfo();
				pTarget->postMessage(message);

				// If another Widget contained the cursor, post a MOUSE_LEFT message to it
				if (g_pCursorWidget)
				{
					Message message;
					message.code = Message::Code::MOUSE_LEFT;
					message.data = MessageGenerator::generateMouseMessageInfo();
					g_pCursorWidget->postMessage(message);
				}
			}

			// Mark that this Widget contains the cursor
			g_pCursorWidget = pTarget;
			absoluteToRelative(*point, pTarget);
			return false;
		}

		pTarget->postMessage(message);
		return true;
	}

	return false;
}

/// <summary>
/// Forwards the message to the widget who is scheduled to receive the timer message
/// </summary>
/// <param name="pReceiver"></param>
/// <param name="message"></param>
/// <returns></returns>
bool Messenger::forwardTimer(Widget* pReceiver, const Message& message)
{
	TimerMessageInfo* pInfo = reinterpret_cast<TimerMessageInfo*>(message.data);

	if (pInfo->pRecipient != pReceiver)
	{
		pInfo->pRecipient->postMessage(message);
		return true;
	}

	return false;
}

/// <summary>
/// Returns the child Widget under a point of the parent Widget.
/// Warning! the point parameter is the point relative to the top left of the app Widget, 
/// not the pParent Widget. The Widget doesn't neet to be an immediate child, for example
/// if A contains child B and B contains child C, then if the cursor is above C, then C is
/// returned, not B.
/// </summary>
/// <param name="pParent">Pointer to parent Widget. It's the app Widget initially.</param>
/// <param name="point">Point in the app Widget.</param>
/// <returns>Pointer to the child Widget under the point</returns>
Widget* Messenger::findChildWidgetUnderPoint(Widget* pParent, const Point& point)
{
	const std::list<Widget*>& children = pParent->getChildren();

	for (auto it = children.rbegin(); it != children.rend(); ++it)
	{
		// If the point that was clicked is inside a child Widget,
		// then we call the function again to check the children of the child.
		if (isPointInWidget(*it, point))
		{
			return findChildWidgetUnderPoint(*it, point);
		}
	}

	// When we reach this point, then we know that there aren't any children 
	// which contain the point, then we check if the point is inside the Widget
	// and then return it.
	// The reason we do this check is because upon calling this function for the first time,
	// the point may not have been inside the given Widget.
	if (isPointInWidget(pParent, point))
	{
		return pParent;
	}

	return nullptr;
}

/// <summary>
/// Converts the given absolute coordinates to relative coordinates (relative to the given Widget)
/// </summary>
/// <param name="point">Reference to the point</param>
/// <param name="pWidget"></param>
void Messenger::absoluteToRelative(Point& point, Widget* pWidget)
{
	point.x -= pWidget->getAbsolutePositionX();
	point.y -= pWidget->getAbsolutePositionY();
}

/// <summary>
/// Checks whether the given point, which is relevant to the top left of the root Widget, is contained
/// by the given Widget.
/// </summary>
/// <param name="pWidget"></param>
/// <param name="point"></param>
/// <returns></returns>
bool Messenger::isPointInWidget(Widget* pWidget, Point point)
{
	const Point ptAbsolute = pWidget->getAbsolutePosition();
	const Size size = pWidget->getSize();

	if (point.x <= ptAbsolute.x + static_cast<int>(size.width) && point.x >= ptAbsolute.x)
	{
		if (point.y <= ptAbsolute.y + static_cast<int>(size.height) && point.y >= ptAbsolute.y)
		{
			return true;
		}
	}

	return false;
}